/*
快速排序、堆排序、选择排序,交换排序不是稳定的排序算法。

冒泡排序，插入排序、归并排序是稳定的排序算法。
排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此。
例如[5 5 8 2 9]  选择排序，交换排序，快速排序会把第一个5和2调换位置，两个5的相对位置就改变了
*/
package main

import "fmt"

func main() {
	var array []int
	var a int
	array = []int{1, 10, 4, 2, 11, 6, 3, 7, 9, 5}
	// 相邻的数不断比较互换，最大（或最小）数就会一直向右移动，如同冒泡一般
	// for i := 0; i < len(array)-1; i++ {
	// 	for j := 0; j < len(array)-1-i; j++ {
	// 		a++
	// 		if array[j] > array[j+1] {
	// 			array[j], array[j+1] = array[j+1], array[j]
	// 		}
	// 	}
	// }

	// 第一个数不断和后面的数比较并互换，最大（或最小）数就会在第一个位置。效率和冒泡一样都是O(n2)，叫交换排序
	// for i := 0; i < len(array)-1; i++ {
	// 	for j := i + 1; j < len(array); j++ {
	// 		a++
	// 		if array[i] > array[j] {
	// 			array[j], array[i] = array[i], array[j]
	// 		}
	// 	}
	// }

	// 选择排序（和交换雷同）  找到最小下标，然后和最前面的数交换（和交换排序的区别是每次找到最小值只进行一次交换）O(n2)
	// for i := 0; i < len(array)-1; i++ {
	// 	n := i
	// 	for j := i + 1; j < len(array); j++ {
	// 		a++
	// 		if array[n] > array[j] {
	// 			n = j
	// 		}
	// 	}
	// 	array[n], array[i] = array[i], array[n]
	// }

	// 插入排序（和冒泡雷同）
	// 第一轮先从第二个元素开始，和第一个比较，如果较小就交换位置，本轮结束。
	// 第二轮从第三个元素开始，先与第二个比较，如果较小就与第二个交换，交换后再于第一个比较。如此循环直至最后一个元素完成比较逻辑。

	// for i := 1; i < len(array); i++ {
	// 	for j := i - 1; j >= 0; j-- {
	// 		a++
	// 		if array[j+1] < array[j] {
	// 			array[j], array[j+1] = array[j+1], array[j]
	// 		}
	// 	}
	// }
	fmt.Println(a)
	fmt.Println(array)

	// 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)
	// 一般升序采用大顶堆，降序采用小顶堆
	/*
			　a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;

		　　b.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;

		　　c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。
					    大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]
						小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]
	*/
}
